//==== ==== ==== ==== ==== header ==== ==== ==== ==== ====
static const char *F_HEADER = R"OO(

//[$header]
//this file generated by automation tool, don't modify it manually.

#import "CQBridgeObject.h"

$loop_cls
@class $objccls;
$end

$need
$loop_cls
$loop_cls_func
CQ_C_LINK $(cret)_objc_$(class)_$cfunc($cparams);
$end
$end

$loop_cls
@interface $objccls : CQBridgeObject
$loop_cls_func
+ ($objcret)$objcfunc;
$end
$loop_obj_func
- ($objcret)$objcfunc;
$end
@end

$end
)OO";

//==== ==== ==== ==== ==== interface source ==== ==== ==== ==== ====
static const char *F_LOCAL_SOURCE = R"OO(

//[$source]
//this file generated by automation tool, don't modify it manually.

#import "$header"

#pragma mark - empty classes

$loop_cls
@implementation $objccls //empty class

$loop_cls_func
+ ($objcret)$objcfunc {
    $(return)_objc_$(class)_$cfunc($cvalues);
}

$end
$loop_obj_func
- ($objcret)$objcfunc {CQ_UNIMPLEMENT;}

$end
@end

$end
#pragma mark - objc class' cpp images

$loop_cls
@interface $(objccls)CPPImage : $objccls //image class
@end

@implementation $(objccls)CPPImage //image class

$loop_obj_func
- ($objcret)$objcfunc {
}

$end
@end

$end
#pragma mark - cpp class' objc images
$loop_cls

cq_class($(cppcls)ObjcImage, $cppcls) {
$loop_obj_func
    $(cppret)$cfunc($cppparams) override;
$end
};

cq_member($(cppcls)ObjcImage) {
};
$loop_obj_func

$(cppret)$(cppcls)ObjcImage::$cfunc($cppparams) {
}
$end
$end

#pragma mark - bridge functions for external

$loop_cls
$loop_cls_func
$(cppret)_cpp_$(class)_$cfunc($cppparams) {
}

$end
$end
)OO";

//==== ==== ==== ==== ==== implementation source ==== ==== ==== ==== ====
static const char *F_BRIDGE_SOURCE = R"OO(

)OO";
